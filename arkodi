#!/usr/bin/env bash

platforms='rpi rpi-2'

read -r -d '' usage << EOF
Install Arch and Kodi on a SD Card
Usage:
  $0 [OPTION [VALUE]]... DRIVE
Options:
  -p  [[${platforms// /]|}] platform
  -h  show this help and quit
Example:
  $0 -p rpi-2 /dev/mmcblk0
EOF

filesystem='ArchLinuxARM-PLATFORM-latest.tar.gz'
url='http://archlinuxarm.org/os/'

depends='bsdtar curl fdisk lsblk md5sum mkfs.ext4 mkfs.vfat sudo udevadm'

set -o errexit
set -o nounset
set -o pipefail
#set -o xtrace

EXIT_SUCCESS="$(true && echo $?)"
EXIT_FAILURE="$(false || echo $?)"

error() {
  echo -e "\e[31mERROR\e[m $@" >&2
  exit ${EXIT_FAILURE}
}

depends_check() {
  for depend in ${depends}; do
    if [ $(grep "${depend}" "$0" | wc -l) -lt 2 ]; then
      echo -e "\e[33mINFO\e[m ${depend} is not a dependency" >&2
    elif ! which ${depend} &> /dev/null; then
      error "This script depens on ${depend}" >&2
    fi
  done
}

drive_check() {

  if ! lsblk "${drive}" &> /dev/null; then
    error "A SD Card drive is expected\n${usage}"
  fi

  if mount | grep --silent ${drive}; then
    error "${drive} should not be mounted"
  fi

  for block in /sys/block/*; do
    info="$(udevadm info --query=property --path=${block})"
    if echo "${info}" | grep --silent "DEVNAME=${drive}";then
      if echo "${info}" | grep --silent "ID_DRIVE_FLASH_SD"; then
        return
      fi
    fi
  done

  error "${drive} is not a SD Card drive."
}

confirm() {
  echo "$@ (yes/no)?"
  read response
  if [ "${response}" != "yes" -a "${response}" != "no" ]; then
    error 'The response should be "yes" or "no"'
  elif [ "${response}" = "no" ]; then
    return ${EXIT_FAILURE}
  else
    return ${EXIT_SUCCESS}
  fi
}

resume_check() {

  cat <<-EOF
Filesystem: ${filesystem}
Platform:   ${platform}
Drive:      ${drive}
EOF

  echo -e "\e[33mWARNING\e[m: This will destroy the content of ${drive}"
  if ! confirm 'Do you want to proceed'; then
    exit
  fi
}

download_check() {
  while true; do
    curl --remote-name --location ${url}${filesystem}.md5
    if md5sum --status --check ${filesystem}.md5; then
      break
    fi
    if [ -f ${filesystem} ]; then
      if ! confirm "${filesystem} MD5 does not match, re-download it"
      then
        exit
      fi
    fi
    curl --remote-name --location ${url}${filesystem}
  done
}

proceed() {

  local script="o\np\nn\np\n1\n\n+100M\nt\nc\nn\np\n2\n\n\nw"
  local filesystem="$1"
  local drive="$2"

  echo -e ${script} | fdisk ${drive}

  mkdir -p boot root

  local partition=$(ls ${drive}?* | sort | head -n 1)
  mkfs.vfat "${partition}"
  mount "${partition}" boot

  local partition=$(ls ${drive}?* | sort | tail -n 1)
  mkfs.ext4 -F ${partition}
  mount "${partition}" root

  bsdtar -xpf "${filesystem}" -C root
  sync

  cp --recursive firstrun root/etc/

  mkdir -p root/etc/systemd/system/network-online.target.wants/
  cp firstrun.service root/etc/systemd/system/

  ln -s /etc/systemd/system/firstrun.service \
    root/etc/systemd/system/multi-user.target.wants/

  mv root/boot/* boot/
  umount boot root

  rm --recursive --force boot root
}

main() {

  drive="${1:-}"
  filesystem="${filesystem/PLATFORM/${platform}}"

  drive_check
  depends_check
  download_check
  resume_check

  if [ "$(whoami)" = "root" ]; then
    proceed "${filesystem}" "${drive}"
  else
    sudo --reset-timestamp bash -c "$(declare -f proceed);
    proceed ${filesystem} ${drive}"
  fi
}

platform="${platforms/ */}"

while getopts 'cn:t:l:p:h' opt; do
  case "${opt}" in
  p) platform="$OPTARG" ;;
  *) echo "${usage}"; exit ;;
  esac
done

shift $((OPTIND-1))
main "$@"

# vim: ts=2 sw=2 sts=2 expandtab smartindent smarttab

